
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async startRecording(settings: TranscriptionSettings) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_recording", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopRecording(appName: string, style: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_recording", { appName, style }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_recording") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pasteText(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("paste_text", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFrontmostApp() : Promise<Result<AppInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_frontmost_app") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if an STT model is downloaded and get its status
 */
async checkSttModelStatus(model: SttModel) : Promise<Result<SttModelStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_stt_model_status", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download an STT model in the background
 */
async downloadSttModel(model: SttModel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_stt_model", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if an LLM model is downloaded and get its status
 */
async checkLlmModelStatus(model: LlmModel) : Promise<Result<LlmModelStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_llm_model_status", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download an LLM model in the background
 */
async downloadLlmModel(model: LlmModel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_llm_model", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current stored shortcut as a string
 */
async getCurrentShortcut() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_shortcut") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Change the global shortcut
 */
async changeShortcut(key: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_shortcut", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unregister the current shortcut (clears the target keys)
 */
async unregisterShortcut() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unregister_shortcut") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all keyterms, optionally filtered by category
 */
async keytermsList(category: KeytermCategory | null) : Promise<Result<Keyterm[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keyterms_list", { category }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single keyterm by ID
 */
async keytermsGet(id: string) : Promise<Result<Keyterm, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keyterms_get", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new keyterm
 */
async keytermsCreate(input: CreateKeytermInput) : Promise<Result<Keyterm, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keyterms_create", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update an existing keyterm
 */
async keytermsUpdate(id: string, input: UpdateKeytermInput) : Promise<Result<Keyterm, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keyterms_update", { id, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a keyterm
 */
async keytermsDelete(id: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keyterms_delete", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all settings
 */
async settingsList() : Promise<Result<Setting[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("settings_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single setting by key
 */
async settingsGet(key: string) : Promise<Result<Setting | null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("settings_get", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set a setting (upsert)
 */
async settingsSet(input: SetSettingInput) : Promise<Result<Setting, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("settings_set", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a setting
 */
async settingsDelete(key: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("settings_delete", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all keys (masked - doesn't expose full API keys)
 */
async keysVaultList() : Promise<Result<KeyVaultEntryMasked[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keys_vault_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a specific API key (full key returned - use with caution)
 */
async keysVaultGet(service: VaultService) : Promise<Result<string | null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keys_vault_get", { service }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set an API key (upsert)
 */
async keysVaultSet(input: SetKeyInput) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keys_vault_set", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete an API key
 */
async keysVaultDelete(service: VaultService) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("keys_vault_delete", { service }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List transcriptions with pagination
 */
async transcriptionsList(params: ListTranscriptionsParams | null) : Promise<Result<PaginatedTranscriptions, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_list", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single transcription by ID
 */
async transcriptionsGet(id: string) : Promise<Result<Transcription, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_get", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new transcription
 */
async transcriptionsCreate(input: CreateTranscriptionInput) : Promise<Result<Transcription, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_create", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update an existing transcription
 */
async transcriptionsUpdate(id: string, input: UpdateTranscriptionInput) : Promise<Result<Transcription, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_update", { id, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a transcription
 */
async transcriptionsDelete(id: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_delete", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get analytics for transcriptions
 */
async transcriptionsAnalytics() : Promise<Result<TranscriptionAnalytics, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transcriptions_analytics") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all notes
 */
async notesList() : Promise<Result<Note[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("notes_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single note by ID
 */
async notesGet(id: string) : Promise<Result<Note, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("notes_get", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new note
 */
async notesCreate(input: CreateNoteInput) : Promise<Result<Note, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("notes_create", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update an existing note
 */
async notesUpdate(id: string, input: UpdateNoteInput) : Promise<Result<Note, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("notes_update", { id, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a note
 */
async notesDelete(id: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("notes_delete", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all shortcuts, optionally filtered by category
 */
async shortcutsList(category: ShortcutCategory | null) : Promise<Result<Shortcut[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shortcuts_list", { category }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single shortcut by ID
 */
async shortcutsGet(id: string) : Promise<Result<Shortcut, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shortcuts_get", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new shortcut
 */
async shortcutsCreate(input: CreateShortcutInput) : Promise<Result<Shortcut, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shortcuts_create", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update an existing shortcut
 */
async shortcutsUpdate(id: string, input: UpdateShortcutInput) : Promise<Result<Shortcut, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shortcuts_update", { id, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a shortcut
 */
async shortcutsDelete(id: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shortcuts_delete", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all writing styles
 */
async writingStylesList() : Promise<Result<WritingStyle[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("writing_styles_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single writing style by category
 */
async writingStylesGet(category: WritingStyleCategory) : Promise<Result<WritingStyle, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("writing_styles_get", { category }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a writing style (upsert)
 */
async writingStylesUpdate(category: WritingStyleCategory, input: UpdateWritingStyleInput) : Promise<Result<WritingStyle, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("writing_styles_update", { category, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AppInfo = { app_name: string; url: string | null }
export type CommandError = { code: ErrorCode; message: string }
export type CreateKeytermInput = { text: string; category: KeytermCategory }
export type CreateNoteInput = { title: string; content: string }
export type CreateShortcutInput = { trigger: string; replacement: string; category: ShortcutCategory }
export type CreateTranscriptionInput = { text: string; formatted_text: string | null }
export type ErrorCode = "DatabaseError" | "NotFound" | "ValidationError" | "DuplicateEntry" | "InvalidInput"
/**
 * Masked version for listing (hides full API key)
 */
export type KeyVaultEntryMasked = { service: string; type: string; has_key: boolean; created_at: number; updated_at: number }
export type Keyterm = { id: string; text: string; category: string; created_at: number; updated_at: number }
export type KeytermCategory = "all" | "Personal" | "Work" | "Email" | "Notes"
export type ListTranscriptionsParams = { limit: number | null; offset: number | null }
/**
 * Large Language Models (Text-to-Text)
 */
export type LlmModel = "Qwen"
/**
 * Status of an LLM model
 */
export type LlmModelStatus = { model: LlmModel; downloaded: boolean; file_size: number | null; path: string | null }
export type Note = { id: string; title: string; content: string; created_at: number; updated_at: number }
export type PaginatedTranscriptions = { items: Transcription[]; total: number; has_more: boolean }
export type SetKeyInput = { service: VaultService; api_key: string }
export type SetSettingInput = { key: string; value: string }
export type Setting = { key: string; value: string; created_at: number; updated_at: number }
export type Shortcut = { id: string; trigger: string; replacement: string; category: string; created_at: number; updated_at: number }
export type ShortcutCategory = "all" | "Personal" | "Work" | "Email" | "Notes"
/**
 * Speech-to-Text models
 */
export type SttModel = "Whisper"
/**
 * Status of an STT model
 */
export type SttModelStatus = { model: SttModel; downloaded: boolean; file_size: number | null; path: string | null }
export type Transcription = { id: string; text: string; formatted_text: string | null; created_at: number }
export type TranscriptionAnalytics = { total_count: number; total_words: number }
export type TranscriptionSettings = { autoDetectLanguage: boolean; languages: string[]; 
/**
 * Keyterms to boost recognition (technical terms, proper nouns, acronyms)
 */
keyterms: string[]; 
/**
 * Whether to use cloud transcription (AssemblyAI)
 */
useCloud: boolean }
export type UpdateKeytermInput = { text: string | null; category: KeytermCategory | null }
export type UpdateNoteInput = { title: string | null; content: string | null }
export type UpdateShortcutInput = { trigger: string | null; replacement: string | null; category: ShortcutCategory | null }
export type UpdateTranscriptionInput = { text: string | null; formatted_text: string | null }
export type UpdateWritingStyleInput = { selected_style: string | null; default_prompt: string | null; custom_prompt: string | null }
export type VaultService = "deepgram" | "groq" | "openai" | "gemini"
export type WritingStyle = { category: string; selected_style: string; default_prompt: string | null; custom_prompt: string | null; updated_at: number }
export type WritingStyleCategory = "Personal" | "Work" | "Email" | "General"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
} from "@tauri-apps/api/core";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

